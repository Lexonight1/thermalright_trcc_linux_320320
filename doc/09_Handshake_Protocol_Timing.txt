TRCC LCD Protocol - Handshake Timing Rules
===========================================

File: 09_Handshake_Protocol_Timing.txt
Created: 2026-01-30
Purpose: Document critical handshake timing differences between Windows and Linux


1. WINDOWS TRCC BEHAVIOR (CORRECT)
───────────────────────────────────

Architecture:
- TRCC.exe (GUI) runs continuously
- USBLCD.exe (daemon) runs in background
- Shared memory IPC: "shareMemory_Image" (38.4 MB)

Initialization Sequence (USBLCD.exe startup):
  Step 1: 0xF5 poll → check device ready (57,600 bytes)
  Step 2: 0x1F5 init → initialize display (57,600 bytes)
  Result: Device enters "ready for frames" state

Frame Streaming (after init):
  TRCC.exe → writes RGB565 to shared memory
  USBLCD.exe → reads from shared memory, sends 4 chunks:
    Chunk 1: 0x101F5    (65,536 bytes)
    Chunk 2: 0x10101F5  (65,536 bytes)
    Chunk 3: 0x20101F5  (65,536 bytes)
    Chunk 4: 0x30101F5  (8,192 bytes)
  Total: 204,800 bytes = 320×320 pixels × 2 bytes/pixel
  
  NO HANDSHAKE BETWEEN FRAMES!

Timing:
- Init once: ~1-2 seconds (0xF5 + 0x1F5 + first frame)
- Subsequent frames: ~200-300ms (4 chunks only)
- Total for 30 FPS video: 30 frames/sec feasible


2. LINUX IMPLEMENTATION (MUST MATCH)
─────────────────────────────────────

Architecture:
- trcc_gui_v2.py (single process, no daemon)
- Direct SCSI commands via sg_raw
- No IPC needed (kernel handles SCSI)

Initialization Sequence (first frame only):
  Step 1: 0xF5 poll → sg_raw READ (57,600 bytes)
  Step 2: 0x1F5 init → sg_raw WRITE (57,600 bytes)
  Step 3: Send first frame (4 chunks)

Frame Streaming (subsequent frames):
  Send 4 chunks only:
    sg_raw WRITE 0x101F5    (65,536 bytes)
    sg_raw WRITE 0x10101F5  (65,536 bytes)
    sg_raw WRITE 0x20101F5  (65,536 bytes)
    sg_raw WRITE 0x30101F5  (8,192 bytes)
  
  NO HANDSHAKE! Device stays initialized.

Code Implementation (trcc_gui_v2.py):
  class FormCZTV:
      def __init__(self):
          self.device_initialized = False  # Track handshake state
      
      def send_to_lcd(self):
          need_init = not self.device_initialized  # Init only on first frame
          if need_init:
              self.device_initialized = True
          
          scsi_send_image(LCD_DEVICE, data, init=need_init)


3. COMMON MISTAKES (AVOID!)
────────────────────────────

❌ WRONG: Handshake on every frame
  Frame 1: 0xF5 + 0x1F5 + 4 chunks  (slow)
  Frame 2: 0xF5 + 0x1F5 + 4 chunks  (device confused)
  Frame 3: 0xF5 + 0x1F5 + 4 chunks  (unstable)
  
  Result: 2-3 seconds per frame, device gets out of sync

✓ CORRECT: Handshake once, stream frames
  Frame 1: 0xF5 + 0x1F5 + 4 chunks  (init)
  Frame 2: 4 chunks only            (fast)
  Frame 3: 4 chunks only            (stable)
  
  Result: 200-300ms per frame, smooth playback

Explanation:
The device firmware expects:
1. ONE initialization sequence (0xF5 + 0x1F5)
2. MANY frame sequences (4 chunks each)
3. NO repeated init unless device is power-cycled or reset

Repeating 0xF5/0x1F5 between frames:
- Wastes bandwidth (~115KB per handshake)
- Confuses device state machine
- Causes flickering/slowdown
- Not how Windows TRCC works!


4. DEVICE STATE MACHINE
────────────────────────

States:
  POWER_ON → device waiting for init
  INITIALIZED → ready to receive frames
  STREAMING → actively displaying frames

Transitions:
  POWER_ON --[0xF5 poll]--> (check ready)
  POWER_ON --[0x1F5 init]--> INITIALIZED
  INITIALIZED --[4 chunks]--> STREAMING
  STREAMING --[4 chunks]--> STREAMING (loop)
  
  ANY_STATE --[power cycle]--> POWER_ON
  ANY_STATE --[timeout 60s]--> ??? (unclear, may reset)

Critical: Once INITIALIZED, device stays ready for frames.
  Do NOT send 0xF5/0x1F5 again unless:
  - Device power-cycled
  - Device unplugged/replugged
  - Explicit reset required


5. PERFORMANCE COMPARISON
──────────────────────────

Protocol Overhead:
  Handshake: 0xF5 (57,600) + 0x1F5 (57,600) = 115,200 bytes
  Frame data: 204,800 bytes
  Total with handshake: 319,200 bytes/frame
  Total without handshake: 204,800 bytes/frame

Timing (estimated):
  USB 2.0 bulk transfer: ~480 Mbps = 60 MB/s
  Handshake time: 115KB / 60MB/s ≈ 1.9ms
  Frame time: 205KB / 60MB/s ≈ 3.4ms
  Total per frame:
    With handshake: ~5.3ms + protocol overhead = ~10-50ms (variable)
    Without handshake: ~3.4ms + protocol overhead = ~5-10ms

Real-world measurements:
  Windows TRCC (handshake once):
    First frame: ~1-2 seconds
    Subsequent: ~200-300ms each
  
  Linux (incorrect, handshake every frame):
    Every frame: ~2-3 seconds (BAD!)
  
  Linux (correct, handshake once):
    First frame: ~1-2 seconds
    Subsequent: ~200-300ms each (GOOD!)


6. VERIFICATION CHECKLIST
──────────────────────────

✓ device_initialized flag tracks handshake state
✓ First frame: need_init = True
✓ Subsequent frames: need_init = False
✓ GUI startup sends black frame with handshake
✓ Theme loads send single frame (no handshake if already init)
✓ Video playback sends frames at fps rate (no handshake)
✓ Live sensor updates send frames at 1Hz (no handshake)

Console Output Should Show:
  [LCD] **** FIRST FRAME - PERFORMING HANDSHAKE (0xF5 + 0x1F5) ****
  [LCD] Sending frame (4 chunks only, no handshake)
  [LCD] Sending frame (4 chunks only, no handshake)
  ...


7. RELATED FILES
─────────────────

Implementation:
- trcc_gui_v2.py: GUI with device_initialized flag (lines 1428-1435)
- trcc_handshake_v2.py: send_image(dev, data, init=bool)
- Thermalright-usblcd/src/CLcdDriver.cpp: C++ driver (reference)

Documentation:
- 01_Windows_vs_Linux_Architecture.txt (IPC comparison)
- 04_LibUsbDotNet_USB_Communication.txt (USB protocol details)

Ghidra Reversing:
- USBLCD.exe lines 20480-20540: Handshake implementation
- TRCC.exe UCScreenImage: Frame rendering + shared memory write


8. KEY INSIGHT (KISS PRINCIPLE)
─────────────────────────────────

Windows Complexity:
- Two processes (TRCC.exe + USBLCD.exe)
- Shared memory IPC
- Daemon keeps device warm
- Why? Historical reasons (driver isolation)

Linux Simplicity:
- One process (trcc_gui_v2.py)
- Direct SCSI commands
- Kernel handles device state
- Result: Simpler, fewer moving parts

But Protocol is IDENTICAL:
- Same command codes (0xF5, 0x1F5, 0x101F5, etc.)
- Same timing requirements (handshake once)
- Same multi-chunk frame structure
- Device firmware doesn't care about OS!

The fix: Match Windows protocol timing, not Windows architecture.


END OF DOCUMENT
